{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LifeFit","text":"<p>LifeFit is a Python package to analyze time-correlated single-photon counting (TCSPC) data sets, namely fluorescence lifetime and time-resolve anisotropy decays.</p> <p>Citation</p> <p>F.D. Steffen, R.K.O. Sigel, R. B\u00f6rner, Phys. Chem. Chem. Phys. 2016, 18, 29045-29055.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest release with pip</p> <pre><code>pip install lifefit\n</code></pre>"},{"location":"#webserver","title":"Webserver","text":"<p>You can run LifeFit directly in your browser. Start the streamlit app from the terminal with:</p> <pre><code>lifefit_gui\n</code></pre> <p></p>"},{"location":"#tutorial","title":"Tutorial","text":"<p>For an introduction into the functionality of LifeFit visit the tutorial.</p>"},{"location":"#bug-reports","title":"Bug reports","text":"<p>Please report any bugs via the issue tracker on Github.</p>"},{"location":"api/","title":"API","text":"<p>Python module to fit time-correlated single photon counting (TCSPC) data</p>"},{"location":"api/#lifefit.tcspc.Anisotropy","title":"Anisotropy","text":"<p>Create an Anisotropy object with four polarization resolved lifetime decays</p> <p>Parameters:</p> Name Type Description Default <code>VV</code> <p>vertical excitation - vertical emission</p> required <code>VH</code> <p>vertical excitation - horizontal emission</p> required <code>HV</code> <p>horizontal excitation - vertical emission</p> required <code>HH</code> <p>horizontal excitation - horizontal emission</p> required <p>Example:</p> <pre><code>&gt;&gt;&gt; lf.tcspc.Anisotropy(decay['VV'], decay['VH'], decay['HV'],decay['HH'])\n</code></pre>"},{"location":"api/#lifefit.tcspc.Anisotropy.G_factor","title":"G_factor  <code>staticmethod</code>","text":"<pre><code>G_factor(HV: np.ndarray, HH: np.ndarray) -&gt; float\n</code></pre> <p>Compute G-factor to correct for differences in transmittion effiency of the horizontal and vertical polarized light</p> <p>Parameters:</p> Name Type Description Default <code>HV</code> <p>horizontal excitation - vertical emission</p> required <code>HH</code> <p>horizontal excitation - horizontal emission</p> required <p>Returns:</p> Type Description <code>float</code> <p>G-factor</p> Note <p>The G-factor is defined as follows $$ G = \\frac{\\int HV}{\\int HH} $$</p>"},{"location":"api/#lifefit.tcspc.Anisotropy.aniso_decay","title":"aniso_decay  <code>staticmethod</code>","text":"<pre><code>aniso_decay(VV: np.ndarray, VH: np.ndarray, G: float) -&gt; np.ndarray\n</code></pre> <p>Compute the anisotropy decay</p> <p>Parameters:</p> Name Type Description Default <code>VV</code> <p>vertical excitation - vertical emission</p> required <code>VH</code> <p>vertical excitation - horizontal emission</p> required <code>G</code> <p>G-factor</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>anisotropy decay</p> Note <p>The anisotropy decay is calculated from the parallel and perpendicular lifetime decays as follows $$ r(t) = \\frac{I_\\text{VV} - GI_\\text{VH}}{I_\\text{VV} + 2GI_\\text{VH}} $$</p>"},{"location":"api/#lifefit.tcspc.Anisotropy.export","title":"export","text":"<pre><code>export(filename)\n</code></pre> <p>Export the data and the fit parameters to a json file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <p>Name of the JSON file</p> required"},{"location":"api/#lifefit.tcspc.Anisotropy.hindered_rotation","title":"hindered_rotation  <code>staticmethod</code>","text":"<pre><code>hindered_rotation(time: np.ndarray, r0: float, tau_r: float, r_inf: float) -&gt; np.ndarray\n</code></pre> <p>Hindered rotation in-a-cone model</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>r0</code> <p>fundamental anisotropy</p> required <code>tau_r</code> <p>rotational correlation time</p> required <code>r_inf</code> <p>residual anisotropy at time-&gt;inf</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>hindered rotation anisotropy decay</p> Hindered-rotation model \\[ f(t) = (r_0 - r_\\infty) \\exp(-t / \\tau_r) + r_\\infty \\]"},{"location":"api/#lifefit.tcspc.Anisotropy.local_global_rotation","title":"local_global_rotation  <code>staticmethod</code>","text":"<pre><code>local_global_rotation(time: np.ndarray, r0: float, tau_rloc: float, r_inf: float, tau_rglob: float) -&gt; np.ndarray\n</code></pre> <p>Local-global rotation in-a-cone model</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>r0</code> <p>fundamental anisotropy</p> required <code>tau_rloc</code> <p>local rotational correlation time</p> required <code>r_inf</code> <p>residual anisotropy at time-&gt;inf</p> required <code>tau_rglob</code> <p>global rotational correlation time</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>local-global rotation anisotropy decay</p> Note <p>Local-global rotation in-a-cone model $$ f(t) = ((r_0 - r_\\infty) \\exp(-t / \\tau_{r,\\text{loc}}) + r_\\infty) \\exp(-t / \\tau_{r,\\text{glob}}) $$</p>"},{"location":"api/#lifefit.tcspc.Anisotropy.one_rotation","title":"one_rotation  <code>staticmethod</code>","text":"<pre><code>one_rotation(time: np.ndarray, r0: float, tau_r: float) -&gt; np.ndarray\n</code></pre> <p>Single rotator model</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>r0</code> <p>fundamental anisotropy</p> required <code>tau_r</code> <p>rotational correlation time</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>two-rotation anisotropy decay</p> One-rotation model \\[ f(t) = r_0 \\exp(-t / \\tau_r) \\]"},{"location":"api/#lifefit.tcspc.Anisotropy.rotation_fit","title":"rotation_fit","text":"<pre><code>rotation_fit(p0: list[float] = [0.4, 1], model: str = 'one_rotation', manual_interval: Optional[tuple[float]] = None, bounds: tuple[float] = (0, np.inf), verbose: bool = True, ns_before_VVmax: float = 1, signal_percentage: float = 0.01)\n</code></pre> <p>Fit rotation model to anisotropy decay.</p> <p>Parameters:</p> Name Type Description Default <code>p0</code> <p>start values of the chosen anisotropy fit model</p> <code>[0.4, 1]</code> <code>model</code> <p>one of the following anisotropy models: {'one_rotation', 'two_rotations', 'hindered_rotation', 'local_global_rotation'}</p> <code>'one_rotation'</code> <code>manual_interval</code> <p>Time interval in which to fit the anisotropy decay</p> <code>None</code> <code>bounds</code> <p>lower and upper bounds for each parameter in p0. Can be either a tuple of two scalars (same bound for all parameters) or a tuple of array_like with the same length as p0. To deactivate parameter bounds set: <code>bounds=(-np.inf, np.inf)</code></p> <code>(0, inf)</code> <code>verbose</code> <p>whether to print anisotropy fit result</p> <code>True</code> <code>ns_before_VVmax</code> <p>how many nanoseconds before the maximum of the VV decay should the search for r0 start</p> <code>1</code> <code>signal_percentage</code> <p>percentage of the VV decay serving as a treshold to define the end of the anisotropy fit interval</p> <code>0.01</code> <p>Example:</p> <pre><code>&gt;&gt;&gt; obj.rotation_fit(p0=[0.4, 1, 10, 1], model='two_rotations')\n</code></pre>"},{"location":"api/#lifefit.tcspc.Anisotropy.two_rotations","title":"two_rotations  <code>staticmethod</code>","text":"<pre><code>two_rotations(time: np.ndarray, r0: float, b: float, tau_r1: float, tau_r2: float) -&gt; np.ndarray\n</code></pre> <p>Two-rotator model</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>r0</code> <p>fundamental anisotropy</p> required <code>b</code> <p>amplitude of second decay</p> required <code>tau_r1</code> <p>first rotational correlation time</p> required <code>tau_r2</code> <p>second rotational correlation time</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>two-rotation anisotropy decay</p> Two-rotation model \\[ f(t) = r_0 \\exp(-t / \\tau_{r1}) + (r_0 - b) \\exp(-t / \\tau_{r2}) \\]"},{"location":"api/#lifefit.tcspc.Lifetime","title":"Lifetime","text":"<p>Create lifetime class</p> <p>Parameters:</p> Name Type Description Default <code>fluor_decay</code> <p>n x 2 array containing numbered channels and intensity counts of the fluorescence decay</p> required <code>fluor_ns_per_chan</code> <p>nanoseconds per channel</p> required <code>irf_decay</code> <p>n x 2 array containing numbered channels and intensity counts for instrument reponse function (IRF). If <code>None</code>, then IRF is approximated by a Gaussian</p> <code>None</code> <code>gauss_sigma</code> <p>standard deviation of the IRF Gaussian</p> <code>None</code> <code>gauss_amp</code> <p>amplitude of the IRF Gaussian</p> <code>None</code> <code>shift_time</code> <p>whether to shift time point 0 to the maximum of the decay</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>ns_per_chan</code> <p>nanoseconds per channel</p> <code>fluor</code> <p>n x 4 array containing time, channel number, intensity counts and associated Poissonian weights of the fluorescence decay</p> <code>irf</code> <p>n x 3 array containing time, channel number and intensity counts of the IRF</p> <code>irf_type</code> <p>type of IRF: {'Gaussian', 'experimental'}</p> <code>fit_param</code> <p>ndarray of fit parameters</p> <code>fit_param_std</code> <p>ndarray of standard deviations of fit parameters</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; fluor, fluor_nsperchan = lf.tcspc.read_decay(pathToFluorDecay)\n&gt;&gt;&gt; irf, irf_nsperchan = lf.tcspc.read_decay(pathToIRF)\n&gt;&gt;&gt; lf.tcspc.Lifetime(fluor, fluor_nsperchan, irf)\n</code></pre>"},{"location":"api/#lifefit.tcspc.Lifetime.average_lifetime","title":"average_lifetime  <code>staticmethod</code>","text":"<pre><code>average_lifetime(a: np.ndarray, tau_val: np.ndarray, tau_std: np.ndarray) -&gt; tuple[float, float]\n</code></pre> <p>Calculate average lifetime according to Lakowicz (2010) [1]</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>weighting factors of tau</p> required <code>tau_val</code> <p>fluorescence lifetimes</p> required <code>tau_std</code> <p>standard deviation of the fluorescence lifetimes</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>average lifetime and associated standard deviation</p> References <p>[1] J. Lakowicz, Principles of Fluorescence, 3rd ed., Springer, 2010.</p>"},{"location":"api/#lifefit.tcspc.Lifetime.convolution","title":"convolution  <code>staticmethod</code>","text":"<pre><code>convolution(irf: np.ndarray, sgl_exp: np.ndarray) -&gt; np.ndarray\n</code></pre> <p>Compute convolution of irf with a single exponential decay</p> <p>Parameters:</p> Name Type Description Default <code>irf</code> <p>intensity counts of the instrument reponse function (experimental of Gaussian shaped)</p> required <code>sgl_exp</code> <p>single-exponential decay</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>convoluted signal of IRF and exponential decay</p>"},{"location":"api/#lifefit.tcspc.Lifetime.exp_decay","title":"exp_decay  <code>staticmethod</code>","text":"<pre><code>exp_decay(time: np.ndarray, tau: float) -&gt; np.ndarray\n</code></pre> <p>Create a single-exponential decay</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>tau</code> <p>fluorescence lifetime</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>single-exponential decay</p> Note <p>Single-exponential decay $$ f(t) = \\exp(-t / \\tau) $$</p>"},{"location":"api/#lifefit.tcspc.Lifetime.from_filenames","title":"from_filenames  <code>classmethod</code>","text":"<pre><code>from_filenames(fluor_file: str, irf_file: str = None, fileformat: str = 'HORIBA', gauss_sigma: Optional[float] = None, gauss_amp: Optional[float] = None, shift_time: bool = False)\n</code></pre> <p>Alternative constructor for the Lifetime class by reading in filename for the fluorophore and IRF decay</p> <p>Parameters:</p> Name Type Description Default <code>fluor_file</code> <p>filename of the fluorophore decay</p> required <code>irf_file</code> <p>filename of the IRF decay</p> <code>None</code> <code>fileformat</code> <p>currently implemented formats: {'HORIBA'}</p> <code>'HORIBA'</code> <code>gauss_sigma</code> <p>standard deviation of the IRF Gaussian</p> <code>None</code> <code>gauss_amp</code> <p>amplitude of the IRF Gaussian</p> <code>None</code> <code>shift_time</code> <p>whether to shift time point 0 to the maximum of the decay</p> <code>False</code> <p>Example:</p> <pre><code>&gt;&gt;&gt; lf.tcspc.Lifetime.from_filenames(pathToFluorDecay, pathToIRFDecay)\n</code></pre>"},{"location":"api/#lifefit.tcspc.Lifetime.gauss_irf","title":"gauss_irf  <code>staticmethod</code>","text":"<pre><code>gauss_irf(time: np.ndarray, mu: float, sigma: float = 0.01, A: float = 10000) -&gt; np.ndarray\n</code></pre> <p>Calculate a Gaussian-shaped instrument response function (IRF)</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <p>time bins</p> required <code>mu</code> <p>mean of the Gaussian distribution</p> required <code>sigma</code> <p>standard deviation of the Gaussian distribution</p> <code>0.01</code> <code>A</code> <p>amplitude of the Gaussian distribution</p> <code>10000</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A Gaussian-shaped instrument response function</p>"},{"location":"api/#lifefit.tcspc.Lifetime.nnls_convol_irfexp","title":"nnls_convol_irfexp","text":"<pre><code>nnls_convol_irfexp(x_data: np.ndarray, p0: list[float]) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]\n</code></pre> <p>Solve non-negative least squares for series of IRF-convolved single-exponential decays. First, the IRF is shifted, then convolved with each exponential decay individually (decays 1,...,n), merged into an m x n array (=A) and finally plugged into <code>scipy.optimize.nnls(A, experimental y-data)</code> to compute <code>argmin_x || Ax - y ||_2</code>. This optimizes the relative weight of the exponential decays whereas the curve_fit function optimizes the decay parameters (tau1, taus2, etc.). See also scipy.optimize.nnls.</p> <p>Parameters:</p> Name Type Description Default <code>x_data</code> <p>array of the independent variable</p> required <code>p0</code> <p>start values for the fit model</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A = matrix containing irf-convoluted single-exponential decays in the first n columns and ones in the last column (background counts)</p> <code>ndarray</code> <p>x = vector that minimizes the 2-norm <code>|| Ax - y ||_2</code></p> <code>ndarray</code> <p>y = fit vector computed as <code>y = Ax</code></p>"},{"location":"api/#lifefit.tcspc.Lifetime.reconvolution_fit","title":"reconvolution_fit","text":"<pre><code>reconvolution_fit(tau0: list[int] = [1], tau_bounds: tuple[float] = (0, np.inf), irf_shift: int = 0, sigma: Optional[np.ndarray] = None, verbose: bool = True)\n</code></pre> <p>Fit the experimental lifetime decay to a series of exponentials via interative reconvolution with the instrument reponse function (IRF).</p> <p>Parameters:</p> Name Type Description Default <code>tau0</code> <p>start value(s) of the fluorescence lifetime(s)</p> <code>[1]</code> <code>tau_bounds</code> <p>lower and upper bounds for each parameter in tau0. Can be either a tuple of two scalars (same bound for all parameters) or a tuple of array_like with the same length as tau0. To deactivate parameter bounds set: <code>bounds=(-np.inf, np.inf)</code></p> <code>(0, inf)</code> <code>irf_shift</code> <p>shift of the IRF on the time axis (in channel units)</p> <code>0</code> <code>sigma</code> <p>uncertainty of the decay (same length as y_data)</p> <code>None</code> <code>verbose</code> <p>whether to print lifetime fit result</p> <code>True</code> <p>Example:</p> <pre><code>&gt;&gt;&gt; obj.reconvolution_fit([1,5])\n</code></pre>"},{"location":"api/#lifefit.tcspc.fit","title":"fit","text":"<pre><code>fit(fun: Callable, x_data: np.ndarray, y_data: np.ndarray, p0: np.ndarray, bounds: tuple[list[float]] = ([0, 0, 0], [np.inf, np.inf, np.inf]), sigma: Optional[float] = None) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Wrapper for the curve_fit function of the scipy.optimize module The curve_fit optimizes the decay parameters (tau1, tau2, etc.) while the nnls weights the exponential decays.</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <p>callable The model function f(x,...) taking x values as a first argument followed by the function parameters</p> required <code>x_data</code> <p>array_like     array of the independent variable</p> required <code>y_data</code> <p>array_like     array of the dependent variable</p> required <code>p0</code> <p>array_like start values for the fit model</p> required <code>bounds</code> <p>2-tuple of float or 2-tuple of array_like, optional     lower and upper bounds for each parameter in p0. Can be either a tuple of two scalars     (same bound for all parameters) or a tuple of array_like with the same length as p0.     To deactivate parameter bounds set: <code>bounds=(-np.inf, np.inf)</code></p> <code>([0, 0, 0], [inf, inf, inf])</code> <code>sigma</code> <p>array_like, optional     uncertainty of the decay (same length as y_data)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>p</code> <code>ndarray</code> <p>optimized fit parameters</p> <code>p_std</code> <code>ndarray</code> <p>standard deviation of optimized fit parameters</p>"},{"location":"api/#lifefit.tcspc.parseCmd","title":"parseCmd","text":"<pre><code>parseCmd() -&gt; tuple[str, str]\n</code></pre> <p>Parse the command line to get the experimental decay and instrument reponse function (IRF) file.</p> <p>Returns:</p> Name Type Description <code>fluor_file</code> <code>str</code> <p>filename of the fluorescence decay</p> <code>irf_file</code> <code>str</code> <p>filename of the IRF (if None then the IRF is approximated by a Gaussian)</p>"},{"location":"api/#lifefit.tcspc.read_decay","title":"read_decay","text":"<pre><code>read_decay(filepath_or_buffer: Union[str, io.StringIO], fileformat: str = 'Horiba') -&gt; tuple[np.ndarray, float]\n</code></pre> <p>Read TCSPC decay file from HORIBA or another data format</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_buffer</code> <p>filename of the decay or StringIO object</p> required <code>fileformat</code> <p>currently implemented formats: {'HORIBA'}</p> <code>'Horiba'</code> <p>Returns:</p> Name Type Description <code>decay_data</code> <code>ndarray</code> <p>n x 2 decay containing numbered channels and intensity counts for instrument response function (IRF)</p> <code>ns_per_chan</code> <code>float</code> <p>timsteps in nanoseconds between channels</p>"},{"location":"tutorial/","title":"Tutorial","text":"In\u00a0[1]: Copied! <pre># import modules\nimport lifefit as lf\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\n# seaborn settings\nsns.set_style('white')\nsns.set_context(\"notebook\")\nsns.set_theme(font='Arial')\n\n# plot settings\ndef set_ticksStyle(x_size=4, y_size=4, x_dir='in', y_dir='in'):\n    sns.set_style('ticks', {'xtick.major.size': x_size, 'ytick.major.size': y_size, 'xtick.direction': x_dir, 'ytick.direction': y_dir})\n</pre> # import modules import lifefit as lf import numpy as np import matplotlib.pyplot as plt import seaborn as sns import os  # seaborn settings sns.set_style('white') sns.set_context(\"notebook\") sns.set_theme(font='Arial')  # plot settings def set_ticksStyle(x_size=4, y_size=4, x_dir='in', y_dir='in'):     sns.set_style('ticks', {'xtick.major.size': x_size, 'ytick.major.size': y_size, 'xtick.direction': x_dir, 'ytick.direction': y_dir}) In\u00a0[2]: Copied! <pre>atto550_dna_path = lf.DATA_DIR.joinpath(\"lifetime\", \"Atto550_DNA.txt\")\nirf_path = lf.DATA_DIR.joinpath(\"IRF\", \"irf.txt\")\n</pre> atto550_dna_path = lf.DATA_DIR.joinpath(\"lifetime\", \"Atto550_DNA.txt\") irf_path = lf.DATA_DIR.joinpath(\"IRF\", \"irf.txt\") <p>Next, we read in our datafile for the fluorescence decay and the instrument response function (IRF). Instead of using the <code>lf.read_decay()</code> function we can define a custom import function that outputs a two-column array containing numbered channels and intensity counts.</p> In\u00a0[3]: Copied! <pre>atto550_dna, timestep_ns = lf.tcspc.read_decay(atto550_dna_path)\nirf, _ = lf.tcspc.read_decay(irf_path)\n</pre> atto550_dna, timestep_ns = lf.tcspc.read_decay(atto550_dna_path) irf, _ = lf.tcspc.read_decay(irf_path) <p>Note: If your intensity counts are along a time axis, i.e. a file with two columns <code>time</code> and <code>intensity</code>, you can use the <code>fileformat=\"time_intensity\"</code> argument of the <code>lf.read_decay()</code> function.</p> In\u00a0[4]: Copied! <pre>atto550_dna, timestep_ns = lf.tcspc.read_decay(lf.DATA_DIR.joinpath(\"lifetime\", \"Atto550_DNA_time_intensity.txt\"), fileformat=\"time_intensity\")\nirf, _ = lf.tcspc.read_decay(lf.DATA_DIR.joinpath(\"IRF\", \"IRF_time_intensity.txt\"), fileformat=\"time_intensity\")\n</pre> atto550_dna, timestep_ns = lf.tcspc.read_decay(lf.DATA_DIR.joinpath(\"lifetime\", \"Atto550_DNA_time_intensity.txt\"), fileformat=\"time_intensity\") irf, _ = lf.tcspc.read_decay(lf.DATA_DIR.joinpath(\"IRF\", \"IRF_time_intensity.txt\"), fileformat=\"time_intensity\") <p>Next we instantiate a <code>Lifetime object</code> by providing the data arrays of the fluorescence decay and the IRF along with the timestep between two channels</p> In\u00a0[5]: Copied! <pre>atto550_dna_life = lf.tcspc.Lifetime(atto550_dna, timestep_ns, irf)\n</pre> atto550_dna_life = lf.tcspc.Lifetime(atto550_dna, timestep_ns, irf) <p>Fit the fluorecence decay by iterative reconvolution with the IRF</p> In\u00a0[6]: Copied! <pre>atto550_dna_life.reconvolution_fit([1,5])\n</pre> atto550_dna_life.reconvolution_fit([1,5]) <pre>=======================================\nReconvolution fit with experimental IRF\ntau0: 1.01 \u00b1 0.01 ns (29%)\ntau1: 3.89 \u00b1 0.01 ns (71%)\nmean tau: 3.61 \u00b1 0.01 ns\n\nirf shift: 0.11 ns\noffset: 1 counts\n=======================================\n</pre> <p>Plot the IRF, the fluorescence decay and the fit</p> In\u00a0[7]: Copied! <pre>with sns.axes_style('ticks'):\n    set_ticksStyle()\n    f, ax = plt.subplots(nrows=1, ncols=1, figsize=(2.5,2.25), sharex=False, sharey=True, squeeze=False)\n    \n    ax[0,0].semilogy(atto550_dna_life.fluor[:,0], atto550_dna_life.fluor[:,2], color=[0.45, 0.57, 0.44])\n    ax[0,0].semilogy(atto550_dna_life.irf[:,0], atto550_dna_life.irf[:,2], color=[0.7,0.7,0.7])\n    ax[0,0].semilogy(atto550_dna_life.fluor[:,0], atto550_dna_life.fit_y, color='k')\n    \n    ax[0,0].set_ylabel('counts')\n    ax[0,0].set_xlabel('time (ns)')\n    ax[0,0].set_xlim((20,80))\n    ax[0,0].set_ylim(bottom=1)\n</pre> with sns.axes_style('ticks'):     set_ticksStyle()     f, ax = plt.subplots(nrows=1, ncols=1, figsize=(2.5,2.25), sharex=False, sharey=True, squeeze=False)          ax[0,0].semilogy(atto550_dna_life.fluor[:,0], atto550_dna_life.fluor[:,2], color=[0.45, 0.57, 0.44])     ax[0,0].semilogy(atto550_dna_life.irf[:,0], atto550_dna_life.irf[:,2], color=[0.7,0.7,0.7])     ax[0,0].semilogy(atto550_dna_life.fluor[:,0], atto550_dna_life.fit_y, color='k')          ax[0,0].set_ylabel('counts')     ax[0,0].set_xlabel('time (ns)')     ax[0,0].set_xlim((20,80))     ax[0,0].set_ylim(bottom=1) In\u00a0[8]: Copied! <pre>atto550_dna_path = {}\natto550_dna = {}\natto550_dna_life = {}\nfor c in ['VV','VH','HV','HH']:\n    atto550_dna_path[c] = lf.DATA_DIR.joinpath(\"anisotropy\", f\"{c}.txt\")\n    atto550_dna[c], fluor_nsperchan = lf.tcspc.read_decay(atto550_dna_path[c])\n    atto550_dna_life[c] = lf.tcspc.Lifetime(atto550_dna[c], fluor_nsperchan, irf)\n</pre> atto550_dna_path = {} atto550_dna = {} atto550_dna_life = {} for c in ['VV','VH','HV','HH']:     atto550_dna_path[c] = lf.DATA_DIR.joinpath(\"anisotropy\", f\"{c}.txt\")     atto550_dna[c], fluor_nsperchan = lf.tcspc.read_decay(atto550_dna_path[c])     atto550_dna_life[c] = lf.tcspc.Lifetime(atto550_dna[c], fluor_nsperchan, irf) <p>Compute an <code>anisotropy object</code> from the lifetime objects and fit a two-rotator model to the anisotropy decay</p> In\u00a0[9]: Copied! <pre>atto550_dna_aniso = lf.tcspc.Anisotropy(atto550_dna_life['VV'], atto550_dna_life['VH'], atto550_dna_life['HV'],atto550_dna_life['HH'])\natto550_dna_aniso.rotation_fit(p0=[0.4, 1, 10,1], model='two_rotations')\n</pre> atto550_dna_aniso = lf.tcspc.Anisotropy(atto550_dna_life['VV'], atto550_dna_life['VH'], atto550_dna_life['HV'],atto550_dna_life['HH']) atto550_dna_aniso.rotation_fit(p0=[0.4, 1, 10,1], model='two_rotations') <pre>====================\nAnisotropy fit\nmodel: two_rotations\nr0: 0.19 \u00b1 0.01\nb: 0.00 \u00b1 0.02\ntau_r1: 8.54 \u00b1 0.48 ns\ntau_r2: 1.63 \u00b1 0.16 ns\n====================\n</pre> <p>Plot the anisotropy decay with the fit</p> In\u00a0[10]: Copied! <pre>with sns.axes_style('ticks'):\n    set_ticksStyle()\n    f, ax = plt.subplots(nrows=1, ncols=1, figsize=(2.5,2.25), sharex=False, sharey=True, squeeze=False)\n    \n    ax[0,0].plot(atto550_dna_aniso.time, atto550_dna_aniso.r, color=[0.45, 0.57, 0.44])\n    ax[0,0].plot(atto550_dna_aniso.time, atto550_dna_aniso.fit_r, color='k')\n    ax[0,0].set_ylim((-0.05,0.4))\n    ax[0,0].set_xlabel('time (ns)')\n    ax[0,0].set_ylabel('anisotropy')\n</pre> with sns.axes_style('ticks'):     set_ticksStyle()     f, ax = plt.subplots(nrows=1, ncols=1, figsize=(2.5,2.25), sharex=False, sharey=True, squeeze=False)          ax[0,0].plot(atto550_dna_aniso.time, atto550_dna_aniso.r, color=[0.45, 0.57, 0.44])     ax[0,0].plot(atto550_dna_aniso.time, atto550_dna_aniso.fit_r, color='k')     ax[0,0].set_ylim((-0.05,0.4))     ax[0,0].set_xlabel('time (ns)')     ax[0,0].set_ylabel('anisotropy')"},{"location":"tutorial/#tutorial","title":"Tutorial\u00b6","text":""},{"location":"tutorial/#lifetime","title":"Lifetime\u00b6","text":"<p>First, define the path to the data</p>"},{"location":"tutorial/#anisotropy","title":"Anisotropy\u00b6","text":"<p>Read the four different fluorescence decays and generate a <code>lifetime object</code> from each channel</p>"}]}